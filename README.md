Форк сделан на основе исходных файлов [CryptoNote](https://cryptonote.org), имеющийся в свободном доступе репозитория [GitHub](https://github.com/cryptonotefoundation/cryptonote)

## Создание форка CryptoNote

Сразу отмечу, что потребуется некоторое оборудование:
не менее 2 серверов с Ubuntu.
Этот ресурс обеспечит поддержку сети на стартовом этапе, а также позволит нашей программе определить ситуацию при первом запуске.

### Первый шаг - выбор наименования валюты

**Будет неплохо придумать красивое и уникальное имя вашему проекту** Проверить на уникальность всегд можно в поисковике и [Криптовалютной карте](mapofcoins.com) 

Для настройки имени потребуется изменить несколько файлов:

**1. В файле src/CryptoNoteConfig.h** - `CRYPTONOTE_NAME` 
Например:
```
const char CRYPTONOTE_NAME[] = "testcoin";
```

**2. В файле src/CMakeList.txt file** - set_property(TARGET daemon PROPERTY OUTPUT_NAME "YOURCOINNAME**d**")

Example: 
```
set_property(TARGET daemon PROPERTY OUTPUT_NAME "testcoined")
```


### Второй шаг. Определение логики валюты

**1. Общее количество выпускаемой валюты** (src/CryptoNoteConfig.h)

Общее количество монет, которые будут выпущены. Если не знаете, сколько поставить, установите (uint64_t) (-1) (равно 18446744073709551616). 
Число также можно определить явно(например, UINT64_C (858986905600000000)).
Пример:
```
const uint64_t MONEY_SUPPLY = (uint64_t)(-1);
```

**2. Кривая эмиссии** (src/CryptoNoteConfig.h)

Определяет скорость снижения стоимости вычислений. Теоретически предполагается, что возрастающие мощности майнеров позволят постепенно снижать сумму вознаграждения, т. к. их ресурс безболезненно позволит с большой скоростью вычислить блок любой сложности.
Изначально установлен, как небольшое снижение цены за каждый вычисленный блок.

`EMISSION_SPEED_FACTOR` константа указывает наклон прямой(чем больше показатель,тем выше эмиссия)

Например:
```
const unsigned EMISSION_SPEED_FACTOR = 18;
```

**3. Целевая сложность** (src/CryptoNoteConfig.h)

Помогает в вычислении идеальной сложности блока, при которой время вы числения каждого из них будет приблизительно равным.
Если же вычисление идет слишком легко, сложность блока возрастает.

Данный параметр позволяет контролировать сразу несколько ключевых аспектов:

- врея подтверждения тразакции: чем более сложные требуются вычисления, тем дольше идет транзакция
- скорость эмиссии: не позволяет более мощным вычислительным системам существенно изменять динамику эмиссии
- цепи с малой сложностью блоков быстро прекращают свое существование.

Для большей стартовой сложности параметр имеет смысл установить от 2 до 5 минут.

Например, так:
```
const uint64_t DIFFICULTY_TARGET = 120;
```

**4. Формула установки вознаграждений**

Логика установки вознаграждений за вычисление блоква определена по следуюшему пути: `src/CryptoNoteCore/Currency.cpp`:
```
bool Currency::getBlockReward(size_t medianSize, size_t currentBlockSize, uint64_t alreadyGeneratedCoins, uint64_t fee, uint64_t& reward, int64_t& emissionChange) const
```
Рекомендую оставить ее в таком виде, если у вас нет более совершенной реализации.
Такая формула состоит из 2 частей:

- Базовые вычисления: `uint64_t baseReward = (m_moneySupply - alreadyGeneratedCoins) >> m_emissionSpeedFactor;`
- защита от слишком быстрого вычисления, штрафование вычислений слишком больших блоков.

Вы можете корректировать параметры DIFFICULTY_TARGET и EMISSION_SPEED_FACTOR и проверить, как будет выглядеть эмиссия вашей монеты.

### Третий шаг.Настройка соединения

**1. Установка портов по умолчанию для P2P и RPC соединения** (src/CryptoNoteConfig.h)

P2P позволяет клиентам связываться с друг-другом в единую сеть.
RPC становится дополнительным способом соединения. Его можно использовать, например, для подключения валютного кошелька.

Используемые порты не должны пересекаться с иным программным обеспечением!

В помощь предлагаю эти ресурсы:

* http://www.speedguide.net/ports.php
* http://www.networksorcery.com/enp/protocol/ip/ports00000.htm
* http://keir.net/portlist.html

Например:
```
const int P2P_DEFAULT_PORT = 11111;
const int RPC_DEFAULT_PORT = 11112;
```


**2. Сетевой идентификатор** 

Данный идентификатор используется для того, чтобы сетевые данные вашей криптовалютной сети не пересекались с данными, которые передаются другими валютами, использующими это же программное обеспечение. Заполните его случайными двоичными значениями.

Измените все байты в указанном файле(src/P2p/P2pNetworks.h):
```
const static boost::uuids::uuid CRYPTONOTE_NETWORK = { { 0xA1, 0x1A, 0xA1, 0x1A, 0xA1, 0x0A, 0xA1, 0x0A, 0xA0, 0x1A, 0xA0, 0x1A, 0xA0, 0x1A, 0xA1, 0x1A } };
```


**3. Стартовые узлы** (src/CryptoNoteConfig.h)

Здесь вы должны указать IP ваших серверов Ubuntu. Именно с них начнется генерация вашей валюты.

Например:
```
const std::initializer_list<const char*> SEED_NODES = {
  "111.11.11.11:17236",
  "222.22.22.22:17236",
};
```


### Четвертый шаг. Кмиссия и сопутствующие параметры.

**1. Минимальная комиссия за транзакцию** (src/CryptoNoteConfig.h)

Отсутствие транзакции позволило бы с легкостью атаковать участников сети потоком невалидных транзакций. Установив минимальное значение, мы сохдаем порог входа, при котором клиенты сети начнут обработку запроса.

Например:
```
const uint64_t MINIMUM_FEE = 100000;
```


**2. Штрафование блоков малых размеров** (src/CryptoNoteConfig.h)

Блокирует флуд с помощью блоков малых размеров.`CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE` число байт.

Например:
```
const size_t CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE = 20000;
```


### Пятый шаг. Префикс адреса.

Можно попробовать определить первый символ(а в некоторых случаях группу символов), с которых будет начинаться публичный адрес монеты.
`CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX` 
[Генератор префиксов адресов](https://cryptonotestarter.org/tools.html).

Например:
```
const uint64_t CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 0x55; // адреса начинаюся с "z"
```


### Шестой шаг. Блок генезиса

**1. Создаем стартовый блок** (src/CryptoNoteConfig.h)

Очистите блок генезиса `const char GENESIS_COINBASE_TX_HEX[]` и компилируйте двоичный файлбез него.

Выглядеть эта строка будет так:
```
const char GENESIS_COINBASE_TX_HEX[] = "";
```


**2. Запуск daemon для генерации первого блока**

Запускаем daemon с `--print-genesis-tx` аргументом. Это позволит создать код транзакции.

Например:
```
testcoined --print-genesis-tx
```


**3. Копирование ключа** (src/CryptoNoteConfig.h)

Полученныйна прошлом этапе хэш необходимо занести в опустошенное на 1 этапе поле `GENESIS_COINBASE_TX_HEX` в файле `src/CryptoNoteConfig.h`

Например:
```
const char GENESIS_COINBASE_TX_HEX[] = "013c01ff0001ffff...785a33d9ebdba68b0";
```


**4. Перекомпиляция**

Перекомпилируйте код снова, т. к. мы внесли изменения. Это был завершающий этап этап создания валюты.

### Седьмой шаг. Конфигурация узлов 
(Инструкция реализовалась для Ubuntu 14.01)

Очевидно, что нужно не только направить запросы к нашим ключевым узлам, но и настроить их для приема данных, то есть, мы должны загрузить нашу программу.

**1. Настройка среды** 
Чтобы получить все необходимое для настройки, введите команду:

```
sudo apt-get install build-essential git cmake libboost1. 55-all-dev
```

**2. Клонирование репозитория**
Создайте репозиторий на GitHub и загрузите созданную вами в первые 6 шагов валюту.
Команда будет иметь вид:
git clone https://github.com/ССЫЛКА_НА_ВАШ_РЕПОЗИТОРИЙ

Например:
```
git clone https://github.com/Nikassaiop/testcoinmaster
```

**3.Открытие папки с опией репозитория**
Для открытия папки с копией репозитория впишите команду:
cd ИМЯ_РЕПОЗИТОРИЯ

Например:

```
cd testcoinmaster
```

**4.Построение валюты**
Заключительным этапом станет запуск процесса построения валюты: 
```
make-j
```

Dependencies: GCC 4.7.3 or later, CMake 2.8.6 or later, and Boost 1.55.

Загрузить их можно здесь:

* http://gcc.gnu.org/
* http://www.cmake.org/
* http://www.boost.org/
* Допустимо использование иных программ и файловых менеджеров, отличающихся функционалом от использованных автром.

